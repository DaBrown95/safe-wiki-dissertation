\chapter{SAFE Wiki}

Ownership of data is very important. With verifiable ownership comes many avenues for interesting applications and is a trait of the network that gravitated me towards the application I decided to build. SAFE Wiki is an application that allows users to both upload and browse content that can be stored in a ZIM file. The ZIM file format allows you to easily store content from the web, one of its uses is in the distribution of Wikimedia based content.

\section{Kiwix}

Kiwix first launched in 2007 as a way to browse the internet ``offline''. It achieves this through the use of ZIM files which are suitable for storing most HTML based content. One of the primary goals of Kiwix is to allow users to browse Wikipedia and other projects from the Wikimedia foundation without an internet connection. Whether this be in the middle of the ocean, Africa or even inside North Korea. Since the initial launch, different versions of the software have been released. Versions support many different platforms including: iOS, Android, Windows Phone, FireFoxOS, macOS, Windows and Linux. A user opens up the app and then through a file explorer (or other means) selects the target ZIM file. Kiwix then presents the user with an almost ``web browser like'' experience. With resources like Wikipedia it looks uncannily like the real thing. Users have the ability to follow hyperlinks around the website (ZIM file) and search for pages. You can see what the London page of a Wikivoyage ZIM file looks like in \textit{Figure \ref{fig:kiwix-firefox}}. With such a fantastic history behind the project I saw Kiwix as the natural foundation to build my application upon. Kiwix is inherently a \textit{Fat Client} style of application as all processing is done on the client. Hence building upon an already \textit{Fat Client} application made perfect sense considering the points made in Chapter \ref{ch:thesafenetwork}. SAFE Wiki would do all the processing/reading of the file locally and use the SAFE Network as the storage medium for ZIM files.

\subsection{Kiwix JS}

Kiwix JS is a JavaScript variant of Kiwix, originally part of the Evopedia project it presents Kiwix in the form of a browser extension. This extension has support for many different environments (FireFox, Chrome, Edge, etc) due to the portable nature of Javascript.

As the SAFE Network is still very much in its infancy the developer API's reflect this. At the time of writing the only API's that are ready for use are the \textit{Node.js API} and what they call the \textit{Web API}. The \textit{Web API} can be used to build websites to interact with the SAFE Network whereas the \textit{Node.js API} facilitates the development of desktop applications. Both of these require the usage of JavaScript, hence forking Kiwix JS to build SAFE Wiki made logical sense.

\begin{figure}
	\begin{center}
			\includegraphics[width=\textwidth]{images/kiwix-js-extension}
		\caption{Kiwix-JS running in FireFox}
		\label{fig:kiwix-firefox}
	\end{center}
\end{figure}

Kiwix JS as it stands has support for Wikimedia and StackOverflow ZIM files (although others may work, just not supported). This meant that if I could get SAFE Wiki working then it would be possible to not only browse Wikimedia content but also content coming from StackOverflow. The content that users would be able to browse would be static, ZIM files are not mutable. The ZIM files being static does however bring its own benefits.

\section{Static versus Dynamic Content}

When the idea to ``build a Wikipedia on the SAFE Network'' first came to mind, I was very well aware of the fact that most likely nobody would use it. It would exist as nothing more than a tech demo with the slight hope that I would be able to continue developing it after I had finished my studies. Getting enough users to start contributing content, and building an environment where strict moderation could occur, would have been a fools-errand given the time permissible for this project. I just wouldn't have been able to build a full Wiki system on the SAFE Network and do it justice.

It is with that realisation that I came to discover Kiwix. Instead of trying to build a Wiki system on the SAFE Network and trying to bring users across, I could bring Wikipedia (and other sites) to the SAFE Network. The content would not be dynamic in anyway (meaning the content couldn't be mutated) but it would be there for consumption. An important thing about this approach is that by the end of the year I could have a working and browsable copy Wikipedia on the SAFE Network. In its entirety. Not just a simple throwaway tech demo but a tool that people might actually be able to use.

Websites like Wikipedia only work because of their user base. When a user edits an article this change is logged and anyone can review the changes made. As there are thousands of users anything that is grievously wrong is likely to be flagged and addressed quickly. If someone is acting as a \textit{bad-party} and editing pages wrongfully they can be blocked based on IP address. A simple example is a school, I don't think it needs explaining that school children can be known for being rather silly sometimes. This behaviour can result in the vandalism of some Wikipedia pages. As this is the case it is trivial for Wikipedia to block the IP address(s) that belongs to a school (from making edits) and prevent any further vandalism. On the SAFE Network, this approach is impossible. A user could simply create another account and vandalise an open wiki all they want. It is for reasons such as this that building a dynamic wiki (with adequate moderation techniques/tools) would have been very difficult. A static mirror of Wikipedia was however very achievable.

A static version of Wikipedia might at first seam quite rigid, but in the context of the SAFE Network it makes sense. As the network has a concept of \textit{ownership of data}, a ZIM file that has been uploaded can be directly tied to an account. The ZIM file belongs to someone (an account) in a verifiable cryptographic manner. An organisation like Wikimedia, or a trusted third-party, can then upload ZIM files to the network with the assurance that users will know it came from them. It will then exist on the network as an un-censorable mirror (or archive) of whatever source the ZIM file came from. Everyone that has access to the SAFE Network can browse it, the only person that is allowed to modify (delete) the file is the holder of the account used to upload the file. As long as you trust the source of the ZIM file, you can \textit{trust} that the information contained within it came from them.

\section{Electron}

Electron allows you to ``Build cross platform desktop apps with JavaScript, HTML, and CSS''. Being able to produce an application that was cross platform was very important to me. The SAFE Network is not platform specific so SAFE Wiki shouldn't be either. As Kiwix JS is built upon web-technologies, Electron seamed like the obvious answer as to how to pull Kiwix JS outside of the web browser. Electron combines \textit{Node.js} and \textit{Chromium} into a single environment that can be deployed to the three main platforms: Windows, Linux and macOS. As there exists a \textit{Node.js API} for the SAFE Network it meant that a single application could be built. An application that could handle both the publishing of ZIM files and facilitate the browsing of them. The decision not to use the \textit{Web API} was because of file uploading. To facilitate the upload of large files, (The ZIM for Wikipedia with images is \textgreater 70GB) I really needed to build a desktop application.

\begin{figure}[h]
	\begin{center}
		\includegraphics[width=\textwidth]{images/kiwix-js-electron}
		\caption{Kiwix JS as an Electron App}
		\label{fig:kiwix-js-electron}
	\end{center}
\end{figure}

Electron and \textit{Node.js} were new frameworks to me. Making Kiwix JS run as an Electron application was hence quite a challenge. After a couple of months of work though I managed to get it running. It was a case of `completely broken' then one fix lead to `completely working'. What was now SAFE Wiki (which you can see in Figure \ref{fig:kiwix-js-electron}) could browse ZIM files from local storage and maintained all the functionality of Kiwix JS.

\section{Developing with the SAFE Network}

Overall I found the SAFE Network exceedingly difficult to work with, this was down to the lack of documentation and developer resources. Being only at `Alpha 2' they still have a long way to go before a true `1.0' release of the product. My assumption is that as time goes on they will create new resources to aid developers, I really would have liked to see resources being developed alongside the alpha stages though. The only saving grace in this matter was the Developer Forum. The Developer Forum is a very lively place with constant chatter and everyone pitching in and sharing ideas. All that I needed to know about how to develop SAFE Network applications was contained in the forum. This was not an optimal way to find the knowledge I needed, it made work very slow and much harder than it needed to be. The lack of documentation and \textit{cannon} knowledge on certain topics resulted in me creating several posts of my own. I was amazed at how quickly people joined in the discussions and I usually had a resolution to my post within a matter of days.

Development first starts with how to orchestrate the connection to the network. During my project I used SAFE Browser, a fork of the Beaker Browser project. SAFE Browser takes the form of a web browser. Through it you can authenticate yourself with the network and browse any websites that are hosted on the SAFE Network, just like you can with a `traditional' web browser. If you build a standalone application, like SAFE Wiki, you can use IPC to communicate with the SAFE Browser to gain authentication with the network. Once you have authentication you can communicate with the network directly meaning you don't need to use SAFE Browser as a middle man. Currently Maidsafe are working on the successor to SAFE Browser called Peruse. 

\begin{figure}[h]
	\begin{center}
		\includegraphics[width=\textwidth]{images/safe-browser-login}
		\caption{Login screen of the SAFE Browser}
		\label{fig:safe-browser-login}
	\end{center}
\end{figure}

To develop with the network you need to have some way of running your own `development' SAFE Network. There are currently three ways of achieving this.
\begin{itemize}
	\item Alpha 2 Network: This network is a public network hosted and ran by Maidsafe themselves. It is the `official' network for early adopters to host websites and run applications against. As it is a public network, it is not optimal for developmental work.
	\item Mock Routing: Mock routing is a technique that is baked into the SAFE Browser and Peruse. What it does is spoof the underlying network to the client through the use of a local database. This means that the client thinks it is talking to a real network while in actuality it is talking to a database. This is a very reliable way of developing locally, although it doesn't give you the full experience of how your application/web-site would work with a `real' SAFE Network. What this method does offer is simplicity. As it is built into the SAFE Browser you only need to download that single application. You just start SAFE Browser (with mock-routing support turned on) and you just work with it as you please.
	\item Local Network: Running a local SAFE Network is my preferred choice. Sadly it was very long into development before I discovered just how easy it was to run a `real' SAFE Network locally. The process isn't as simple as downloading the binaries and clicking run, but it is not difficult. One has to download and compile the `safe\_vault' from Maidsafe's GitHub. This is a \textit{vault} that makes up the nodes of the SAFE Network. Once you have it configured, you then start up several vaults and they will automatically connect to one another. Once you have reached the `min\_section\_size` you set, then you can reliably start using the network for development. The `min\_section\_size` setting is used to configure the minimum number of vaults required to form one complete \textit{section} on the network. As mentioned previously the default value is eight, but you can configure it to be much lower to make running the \textit{vaults} on one machine much easier.
\end{itemize}

\subsection{Web Hosting Manager Example Application}

Maidsafe themselves provide a number of Electron example applications\cite{example-apps}. Looking through the code and how they worked was very helpful in figuring out how the \textit{Node.js API} actually worked. A big challenge for me was just trying to figure out how SAFE applications should be designed, how they should authenticate themselves with the network and such. Design patterns for how to do a lot of these things will be established and grow naturally as more and more developers start working with the SAFE Network. For my purposes, I really liked the style of how the `Web Hosting Manager'\cite{web-hosting-manager} example app worked. Web Hosting Manager is an application that can be used to upload websites to the SAFE Network. As such, it uses almost all of the API for numerous purposes meaning it was easy for me to learn how the vast majority of it should be used. One thing I noticed across all the example apps was repeating code. I don't think it could be defined as `boilerplate' necessarily but nonetheless it was repeating code. This led me to the decision to simply `fork' the internal workings of Web Hosting Manager into SAFE Wiki as I would just be repeating code the same as Maidsafe has done. What I brought into SAFE Wiki was essentially the inner workings of the application. My application uses the SAFE Network in a far simpler way, so I only took the parts that would be useful in my application. Most notably was the code for reading local files to then upload to the network. By adapting the code from inside Web Hosting Manager I was able to use the SAFE Network in a way that is closest to what Maidsafe intended. As mentioned previously there really are no guidelines on how applications should be built, so I thought the most proper way would be to follow what Maidsafe themselves had done. Proper attribution has been added to any and all source files that are not of my own creation, this includes files from Kiwix JS. Most files have seen significant changes to them as I developed my solution and my own style of doing things, the complete history of the changes can be seen on the SAFE Wiki GitHub page.

\section{Authentication}

For an application to have connectivity with the SAFE Network, it has to be authenticated. Regardless of whether it is a website or a standalone application. Communication from my application to the SAFE Browser for authentication was one of the most difficult parts of this project. As Electron allows (encourages) cross-platform development, what worked on a Windows computer might not work on Linux or macOS (the platform I worked on). Getting SAFE Wiki to run on all supported platforms was trivial, it just worked straight away. Getting SAFE Wiki to communicate with the SAFE Browser on all platforms was extremely difficult. Luckily, a community member had published an example SAFE Network Electron app called `safe app base'\cite{safe-app-base}. This application is a modified version of the application from the `Electron Quick Start' guide\cite{electron-quick-start}, which made understanding how it worked very easy. The app itself is very basic, all it does is ask the SAFE Browser for authentication then creates a new \textit{Mutable Data Structure} and prints it to console. I discovered though that on macOS the application didn't work. What would happen is the SAFE Browser would successfully authenticate but the application would never receive the response needed to communicate with the network. I managed to deduce that the issue was regarding how URI Schemes are registered across the system. The mechanics of how this works differs across the platforms so what works on one operating system may not work on another. Differences on how you run the application also has an impact. What may work when running the application from terminal (through the `electron` command) might not work when the application has been packaged as a binary. Indeed there are even differences depending on which Electron package you use to bundle/package the application.

\begin{figure}
	\begin{center}
		\includegraphics{images/safe-app-base}
		\caption{SAFE App Base with newly created Mutable Data structure}
		\label{fig:safe-app-base}
	\end{center}
\end{figure}

This was a big setback for me because if this simple example application didn't work then it would prove difficult to implement my own application. To help solve this I created a forum post\cite{safe-app-base-forummacfix} to discuss the issue with the community. I thought it best to fix the example app before trying to implement the code in SAFE Wiki. After some conversation with numerous people I managed to deduce how to solve the problem, I made the fix myself myself\cite{safe-app-base-fix} and it got merged into the `safe app base' example application. You can see the working application in Figure \ref{fig:safe-app-base}. Problems with URI Schemes cropped up later on in development too, resulting in another forum post\cite{uri-scheme-ubuntu}. This time the issue was with support on Ubuntu. Thanks to the help of the creator of `safe app base' I managed to get this issue fixed quickly. Resulting in me confirming support of SAFE Wiki across Windows, macOS and Linux.

\section{NFS Emulation}

To support the storage of ZIM files on the SAFE Network, SAFE Wiki makes use of the NFS emulation support that the \textit{Node.js API} has. This `emulation' is just a wrapper around Immutable and Mutable Data structures that makes working with `files' much easier. In SAFE Wiki nomenclature there is the concept of a \textit{ZIM folder}. This `folder' is really a Mutable Data structure that is emulated as a folder through NFS. Within this folder are placed the ZIM files that a given user uploads.

\subsection{ZIM Folder}

Every account on the SAFE Network has a number of Mutable Data structures by default that are called \textit{containers}. These \textit{containers} are similar to a `home folder' on a traditional OS in that they give applications structure (guidance) on where to store things. Such containers include: \_public, \_downloads, \_music, \_pictures, \_videos, etc. The ZIM folder that SAFE Wiki uses is stored within the \_public container because data stored within there can be `un-encrypted' or `public' data. Within the \_public container is placed a key value pairing where the key is `zim' and the value is the XOR Address of a Mutable Data structure that is the `ZIM folder'. When a user creates a `ZIM folder', they must specify a name. That name is then hashed to give a unique 256-Bit XOR address which is where the `zim folder' is then stored. Thus through the name of the `ZIM folder' another user can locate the ZIM files uploaded by any other user.

\subsection{ZIM Files}

Once a user has created a ZIM folder they are then able to upload ZIM files to the network. This is achieved through the use of the NFS emulation support of the \textit{Node.js API}.  When a user uploads their ZIM file they give it a name, this name is important. This name is the `file name' of the file, meaning that within a given `zim folder' the ZIM file is stored against the name the user specifies.

\begin{figure}[h]
	\begin{center}
		\includegraphics[width=\textwidth]{images/safe-wiki-uploading-coffee}
		\caption{Uploading the Coffee StackOverflow ZIM file to the SAFE Network}
		\label{fig:safe-upload-coffee}
	\end{center}
\end{figure}

To access a ZIM file, all a user has to provide to SAFE Wiki is the name of the `ZIM folder' and the name of the `ZIM file' within that folder. This approach means it is easy to share access to ZIM files, as names can be human readable they are as easy to share as website URLs. The resolution of the 256-Bit XOR address of the ZIM Folder is through hashing. As the target ZIM folder was stored at the 256-Bit address corresponding to the name specified by the owner of the ZIM folder, the address is then derivable by anyone else that knows the name. The way I envision this being used is the name of the ZIM folder can correspond to the originator of the content then the filenames follow on logically from that. For example, `Wikimedia' could be the name of the ZIM folder then `Wikipedia' could be the name of the ZIM file. Meaning a user has two words to type in to browse the latest version of Wikipedia. As things are organised like this it then becomes logical to derive the location of other ZIM files. A user can deduce that to get to `WikiVoyage' is as simple as `Wikimedia' and `WikiVoyage'.

\section{Reading ZIM Files}
 
An important feature that is facilitated through the use of \textit{Data Maps}(Section \ref{subsec:self-encryption-data-map}) is being able to randomly seek through files. The \textit{Data Map} contains enough information about a file that you can read arbitrary bytes from the file without your client having to download and assemble the entire file. For ZIM files this is important, it is illogical for SAFE Wiki to have to download the = entire Wikipedia so that you can read through a single article. 

\begin{figure}
	\begin{center}
		\includegraphics[width=\textwidth]{images/safe-wiki-browsing-coffee}
		\caption{Browsing a page from the StackOverflow Coffee ZIM file on the SAFE Network}
		\label{fig:browsing-coffee}
	\end{center}
\end{figure}

Kiwix JS by itself is setup to read ZIM files from local storage. To read files from the network all that happens is instead of reading a number of bytes (specified by `begin' and `size' in Figure\ref{fig:zim-read-code}) from local storage, the request is directed to the SAFE Network. Doing it this way is convenient because it doesn't require a complete overhaul of file reading in Kiwix JS. This approach, being more modular in design, means that the original functionality of Kiwix JS is maintained. You can select whether to read files locally or to read them from the SAFE network. In the Code Listing \ref{fig:zim-read-code} you can see how simple this code is. All that happens is the `zimFolder' that is a Mutable Data structure is emulated using NFS. Then the `file' is fetched through the `filename' specified by the user (e.g. `wikipedia'). To then read the required bytes is simple. In Figure \ref{fig:browsing-coffee} you can see in the console on the right hand side the discrete reads from the network. The API handles all of the complexities of navigating the \textit{Data Map(s)} for you. It's always good when complexities like this are abstracted away from the developer.

\begin{figure}[h]
\begin{lstlisting}[frame=single]
readZim (zimFolder, filename, begin, size) {
  return new Promise(async (resolve, reject) => {
    try {
      const nfs = zimFolder.emulateAs('NFS')
      let file = await nfs.fetch(filename)
      file = await nfs.open(file, CONSTANTS.FILE_OPEN_MODE.OPEN_MODE_READ)
      let data = await file.read(begin, size)
      file.close()
      resolve(data)
    } catch (error) {
      reject(error)
    }
  })
}
\end{lstlisting}
\caption{Code to read a ZIM file from the SAFE Network}
\label{fig:zim-read-code}
\end{figure}










