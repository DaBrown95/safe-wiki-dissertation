\chapter{SAFE Wiki}

Ownership of data is very important. With verifiable ownership comes many avenues for interesting applications and is a trait of the network that gravitated me towards the application I decided to build. SAFE Wiki is an application that allows users to both upload and browse content that can be stored in a ZIM file. The ZIM file format allows you to easily store content from the web, one of its uses is in the distribution of Wikimedia based content.

\section{Kiwix}

Kiwix was first launched in 2007 as a way to browse the internet \textit{offline}. It achieves this through the use of ZIM files which are suitable for storing most HTML based content. One of the primary goals of Kiwix is to allow users to browse Wikipedia, \textit{"the sum of all human knowledge"}, offline. Whether this be in the middle of the ocean, deepest Africa or even inside North Korea. Since the initial launch, different versions of the software have been released. Different versions support many different platforms, including: iOS, Android, Windows Phone, FireFoxOS, macOS, Windows and Linux. With such a fantastic history behind the project I saw Kiwix as the natural foundation to build my application on. Kiwix is inherently a \textit{Fat Client} style of application. It does not rely on a network connection as that is the whole point of its existence. Hence building upon an already \textit{Fat Client} application made perfect sense, considering the points made in Chapter \ref{ch:thesafenetwork}. SAFE Wiki would do all the processing/reading of the file locally, using the SAFE Network only as a storage medium for the ZIM files.

Simply, Kiwix provides the means to browse the content within ZIM files. A user opens up the app and then through a file explorer (or other means) selects the target ZIM file. Kiwix then presents the user with an almost \textit{web-browser like} experience. With resources like Wikipedia it looks uncannily like the \textit{real} thing. With the ability to follow links around the website (ZIM file) and search for pages. You can see what the London page of a Wikivoyage ZIM file looks like in \textit{Figure \ref{fig:kiwix-firefox}}.

\subsection{Kiwix JS}

Kiwix JS is a Javascript variant of Kiwix, originally part of the Evopedia project it presents Kiwix in the form of a browser extension. This extension has support for many different environments (FireFox, Chrome, Edge, etc) due to the portable nature of Javascript. As the SAFE Network is still very much in its infancy, the developer API's reflect this. At the time of writing, the only API's that are ready for use are \textit{Node.js} and what they call the \textit{Web API}. Both of these require the usage of Javascript. Hence forking Kiwix JS and building SAFE Wiki on-top of it was a natural choice.

\begin{figure}
	\begin{center}
			\includegraphics[width=\textwidth]{images/kiwix-js-extension}
		\caption{Kiwix-JS running in FireFox}
		\label{fig:kiwix-firefox}
	\end{center}
\end{figure}

Kiwix JS as it stands has support for Wikimedia and StackOverflow ZIM files (although others may work, just not supported). This meant that if I could get SAFE Wiki working then it would be possible to not only browse Wikimedia content but also content coming from StackOverflow. The content that users could browse on the SAFE Network would be static, but with that comes some benefits.

\section{Static versus Dynamic Content}

When the idea to 'build a Wikipedia on the SAFE Network' first came to mind, I was very well aware of the fact that most likely nobody would use it. It would exist as nothing more than a tech demo with the slight hope that I would be able to continue developing it after I had finished my studies. Getting enough users to start contributing content, and building an environment where strict moderation could occur, would have been a fools-errand. Especially in the time permissible for this project. I just wouldn't have been able to build a full Wiki system on the SAFE Network and do it justice.

It is with that realisation that I came to discover Kiwix. Instead of trying to build a Wiki system on the SAFE Network and trying to bring users across, why not bring Wikipedia (and other sites) to the SAFE Network. This wouldn't be dynamic in anyway (in that users can edit the content) but it would be there for consumption. The storage of the data facilitated by all the features that the SAFE Network has to offer. An important thing about this approach is that by the end of the year I could have a working and browsable copy Wikipedia on the SAFE Network. In its entirety. Not just a simple throwaway tech demo, but a tool that people might actually be able to use.

Websites like Wikipedia only work because of their user base. When a user edits an article this change is logged and anyone can review any changes made. As there are thousands of users anything that is grievously wrong is likely to be flagged and addressed quickly. Similarly if someone is acting as a \textit{bad-party} and editing pages wrongfully (think governments editing pages of staff members to make them appear in a better light) can be blocked based on IP address. This simple measure means that, in most cases, edits are tied to an IP address and hence can be blocked. A simple example is a school, I don't think it needs explaining that school children can be known for being rather silly sometimes. Resulting in the vandalism of some Wikipedia pages. As this is the case it is trivial for Wikipedia to block the IP address(s) that belongs to a school (from making edits) and prevent any further vandalism. On the SAFE Network, this approach is impossible. A user could simply create another account and vandalise an open wiki all they want. It is for reasons such as the ones outlined above that building a dynamic wiki (with adequate moderation techniques/tools) would have been very difficult and most likely a fools errand with the time I have allotted for this project. A static Wiki however, was very achievable.

A static version of Wikipedia might at first seam quite rigid, but in the context of the SAFE Network it makes sense. As the network has a concept of \textit{ownership of data}, a ZIM file that has been uploaded can be directly tied to an account. The ZIM file belongs to someone (an account) in a verifiable \textit{cryptographic} manner. An organisation like Wikimedia, or a trusted third-party, can then upload ZIM files to the network with the assurance that users will know it came from them. It will then exist on the network as an un-censorable mirror (or archive) of whatever source the ZIM file came from. Everyone that has access to the SAFE Network can access it, the only person that is allowed to modify (delete) the file is the holder of the account used to upload the file. As long as you trust the source of the ZIM file, you can \textit{trust} that the information contained within it came from them.

The combination of Kiwix and the SAFE Network makes total sense within this context. A strong pedigree, and the foundation to read and process the ZIM files (static content), meant I could build a tool that could be useful to many people around the world.

\section{Electron}

Electron allows you to "Build cross platform desktop apps with JavaScript, HTML, and CSS". Being able to produce an application that was cross platform was very important to me. The SAFE Network is not platform specific so SAFE Wiki shouldn't be either. As Kiwix JS is built upon web-technologies, Electron seamed like the obvious answer as to how to pull Kiwix JS outside of the web browser environment. Under the hood, Electron combines \textit{Node.js} and \textit{Chromium} into a single environment that can be deployed to the three main platforms: Windows, Linux and macOS. As there exists a \textit{Node.js API} for the SAFE Network this meant that a single application could be built. A single application that could handle both the uploading and deletion of ZIM files on the network and also the browsing of them. The decision not to use the \textit{Web API} to make SAFE Wiki was born out of the requirement of file uploading. To facilitate the upload of large files, (The ZIM for Wikipedia with images is \textgreater 70GB) I really needed to build a desktop application.

\begin{figure}[h]
	\begin{center}
		\includegraphics[width=\textwidth]{images/kiwix-js-electron}
		\caption{Kiwix JS as an Electron App}
		\label{fig:kiwix-js-electron}
	\end{center}
\end{figure}

Electron, and indeed Javascript, was very much a new world to me. Beyond simple web development I really haven't done anything note worthy in Javascript. Making Kiwix JS run as an Electron application was hence quite a challenge. After a couple of months of work though I managed to get it running. It was a case of 'completely broken' then one fix lead to 'completely working'. What was now SAFE Wiki (which you can see in Figure \ref{fig:kiwix-js-electron}), could browse ZIM files from local storage and maintained all the functionality of Kiwix JS.

\section{Developing with the SAFE Network}

Overall I found the SAFE Network exceedingly difficult to work with. I truly have never seen such poor attention to documentation and developer resources. My guess as to why this is is because they are still in development. Being only at `Alpha 2' they still have a long way to go before a true `1.0' release of the product. From that perspective I can forgive them. The only saving grace in this matter was the Developer Forum. The Developer Forum is a very lively place with constant chatter and everyone pitching in and sharing ideas. All that I needed to know about how to develop (work with) the network was contained in the forum. This was not an optimal way to find the knowledge I needed, it made work very slow and much harder than it needed to be. The lack of documentation and \textit{cannon} knowledge on certain topics resulted in me creating several posts of my own. I was amazed at how quickly people joined in the discussions and I usually had a resolution to my post within a matter of days.

Development first starts with how to orchestrate the connection to the network. During my project I used SAFE Browser, a fork of the Beaker Browser project. SAFE Browser takes the form of a web browser. Through it you can authenticate yourself with the network and browse any websites that are hosted on the SAFE Network, just like you can with a `traditional' web browser. If you build a standalone application, like SAFE Wiki, you can use IPC to communicate with the SAFE Browser to gain authentication with the network. Once you have authentication you can communicate with the network directly meaning you don't need to use SAFE Browser as a middle man. Currently Maidsafe are working on the successor to SAFE Browser called Peruse, I don't have much experience with it so I can't comment on its utility. 

\begin{figure}[h]
	\begin{center}
		\includegraphics[width=\textwidth]{images/safe-browser-login}
		\caption{Login screen of the SAFE Browser}
		\label{fig:safe-browser-login}
	\end{center}
\end{figure}

To develop with the network you need to have some way of running your own `development' SAFE Network. There are currently three ways of achieving this.
\begin{itemize}
	\item Alpha 2 Network: This network is a public network hosted and ran by Maidsafe themselves. It is the `official' Network for early adopters to host websites and run applications against. As it is a public network, it is not optimal for developmental work.
	\item Mock Routing: Mock routing is a technique that is baked into the SAFE Browser and Peruse. What it does is \textit{spoof} the underlying network to the client through the use of a local Database. This means that the client thinks it is talking to a real network while in actuality it is talking to a local database. This is a very reliable way of developing locally, although it doesn't give you the full experience of how your application/web-site would work with a `real' SAFE Network. What this method does offer is simplicity. As it is built into the SAFE Browser, that is the only download you have to make. You just start SAFE Browser (with mock-routing support turned on) and you just work with it as you please.
	\item Local Network: Running a local SAFE Network is my preferred choice. Sadly it was very long into development before I discovered just how easy it was to run a `real' SAFE Network locally. The process isn't as simple as downloading the binaries and clicking run, but it is not difficult. One has to download and compile the `safe\_vault' from Maidsafe's GitHub. This is a \textit{vault} that makes up the nodes of the SAFE Network. Once you have it configured, you then start up several vaults and they will automatically connect to one another. Once you have reached the `min\_section\_size` you set, then you can reliably start using the network for development. The `min\_section\_size` setting is used to configure the minimum number of vaults required to form one complete \textit{section} on the network.
\end{itemize}

\subsection{Web Hosting Manager Example Application}

Maidsafe themselves provide a number of Electron example applications\cite{example-apps} . Looking through the code and how they worked was very helpful in figuring out how the \textit{Node.js} API actually worked. A big challenge for me was just trying to figure out how SAFE applications should be designed, like how they should authenticate themselves with the network and such. Design patterns for how to do a lot of these things will be established and grow naturally as more and more developers start working with the SAFE Network. For my purposes, I really liked the style of how the `Web Hosting Manager`\cite{web-hosting-manager} example app worked. Web Hosting Manager is an application that can be used to upload websites to the SAFE Network. As such, it uses almost all of the API for numerous purposes meaning it was easy for me to learn how the vast majority of it should be used. One thing I noticed across all the example apps was repeating code. I don't think it could be defined as `boilerplate' necessarily but nonetheless it was repeating code. This led me to the decision to simply `fork' the internal workings of Web Hosting Manager into SAFE Wiki as I would just be repeating code the same as Maidsafe has done. What I brought into SAFE Wiki was essentially the inner workings of the application. My application uses the SAFE Network in a far simpler way, so I only took the parts that would be useful in my application. Most notably was the code for reading local files to then upload to the network. By adapting the code from inside Web Hosting Manager I was able to use the SAFE Network in a way that is closest to what Maidsafe intended. As mentioned previously there really are no guidelines on how applications should be built, so I thought the most proper way would be to follow what Maidsafe themselves had done. Proper attribution has been added to any and all source files that are not of my own creation. This includes files from Kiwix JS. Most files have seen significant changes to them as I developed my solution and my own style of doing things, the complete history of the changes can be seen on the SAFE Wiki GitHub page.

\section{Authentication}

For an application to have connectivity with the SAFE Network, it has to be authenticated. Regardless of whether it is a website or a standalone application. Communication from my application to the SAFE Browser for authentication was one of the most difficult parts of this project. As Electron allows (encourages) cross-platform development, what worked on a Windows computer might not work on Linux or macOS (the platform I worked on). Getting SAFE Wiki to run on all supported platforms was trivial, it just worked straight away. Getting SAFE Wiki to communicate with the SAFE Browser for authentication proved to be extremely difficult. Luckily, a community member had published an example SAFE Network Electron app called `safe app base'\cite{safe-app-base}. This application is a modified version of the application from the `Electron Quick Start' guide\cite{electron-quick-start}, which made understanding how it worked very easy. The app itself is very basic, all it does is ask the SAFE Browser for authentication then creates a new \textit{Mutable Data Structure} and prints it to console. I discovered though that on macOS the application didn't work. What would happen is the SAFE Browser would successfully authenticate but the application would never receive the \textit{auth-uri} needed to communicate with the network. I managed to deduce that the issue was regarding how URI Schemes are registered across the system. The mechanics of how this works differs across the platforms, so what works on one operating system may not work on another. Differences on how you run the application also has an impact. What may work when running the application from terminal (through the `electron` command) might not work when the application has been packaged as a binary. Indeed there are even differences depending on which Electron package you use to bundle/package the application.

\begin{figure}
	\begin{center}
		\includegraphics{images/safe-app-base}
		\caption{SAFE App Base with newly created Mutable Data structure}
		\label{fig:safe-app-base}
	\end{center}
\end{figure}

This was a big setback for me because if this simple example application didn't work then it would prove difficult to implement my own application. To help solve this I created a forum post\cite{safe-app-base-forummacfix} to discuss the issue with the community, I thought it best to fix the example app so that I would learn in the process and it would help other users. After some conversation with numerous people I managed to deduce how to solve the problem, I made the fix myself myself\cite{safe-app-base-fix} and it got merged into the `safe app base example application. You can see the working application in Figure \ref{fig:safe-app-base}. Problems with URI Schemes cropped up later on in development too, resulting in another forum post\cite{uri-scheme-ubuntu}. This time the issue was with support on Ubuntu, thanks to the help of the creator of `safe app base' I managed to get this issue fixed quickly. Resulting in me confirming support across Windows, macOS and Linux.

\section{NFS Emulation}

To support the storage of ZIM files on the SAFE Network, SAFE Wiki makes use of the NFS emulation support that the \textit{Node.js} API has. This `emulation' is just a wrapper around both Immutable and Mutable Data Structures on the network that makes working with `files' much easier. In SAFE Wiki nomenclature there is the concept of a \textit{ZIM folder}. This `folder' is really a Mutable Data Structure that is emulated as a folder through NFS. Within this folder are placed the ZIM files that a given user uploads.

\subsection{ZIM Folder}

Every \textit{account} on the SAFE Network has a given number of Mutable Data Structures by default that are called \textit{containers}. These containers are similar to a 'home folder' on a traditional OS in that they give applications structure (guidance) on where to store things. Such containers include: \_public, \_downloads, \_music, \_pictures, \_videos etc. The ZIM folder that SAFE Wiki uses is stored within the \_public container because data stored within there can be `un-encrypted' or `public' data. Note this doesn't mean that data is not encrypted within vaults, it still goes through the process of self encryption, it just means the keys necessary are publicly derivable. Within the \_public container then is a key value pairing where the key is `zim' and the value is the XOR Address of a Mutable Data structure that is the `zim folder'. When a user creates a `zim folder', they must specify a name for that folder. That name is then hashed to give an address which is a unique 256-Bit XOR address, the address at which the Mutable Data Structure will be stored on the network. Thus through the name of the `zim folder', another user can locate the zim files uploaded by any other user.

\subsection{Immutable Data, Data Maps and ZIM Files}

Once a user has created a ZIM folder, they are then able to upload ZIM files to the network. This is achieved through the use of the NFS  emulation support of the \textit{Node.js}. The target ZIM folder is emulated as a folder using NFS, then a ZIM file is placed within this folder. As the ZIM folder itself is a Mutable Data Structure, it allows for key-value pairings. In this case, the key-value pairs are ZIM file name to Immutable Data.

At all addresses in 256 XOR Address space, the SAFE Network is capable of storing a 1MiB chunk of data. This is regardless of whether or not the chunk is Immutable or Mutable Data. Immutable Data is best used for storing binary data but at only 1MiB in size you have to split large amounts of data across different chunks. This is handled by self-encryption through the use of 'Data Maps'. When self-encryption is used on a file, it ultimately breaks a file down into < 1MiB chunks of data. Each of these chunks has a unique 256-Bit XOR Address which is where it will be stored in the network. To keep track of all of this, a DataMap for the data is created. The Data Map contains several pieces of information:

\begin{itemize}
	\item chunk\_num u32: Specifies how many chunks of data are within the Data Map
	\item hash Vec\textless u8\textgreater: Post-encryption hash of the given chunk
	\item pre\_hash Vec\textless u8\textgreater: Pre-encryption hash of the given chunk
	\item source\_size u64: The size of the original piece of data, before any encryption has taken place
\end{itemize}

Once this Data Map is stored on the SAFE Network, it is then possible to reconstruct and read files of any given size. A Data Map is itself a piece of Immutable Data, so it too can be put through the self-encryption process. What this means is that you can have files stored on the network that are bigger than the max size a 1MiB Data Map can handle. Self-encryption of Data Maps means they are broken into chunks and stored in a Data Map themselves, creating almost a hierarchy of Data Maps for a given file. This ability is very important to SAFE Wiki as some ZIM files are very large (\textgreater 75GB). The API abstracts all the complexities of DataMaps away from the developer which means you don't really need to consider all of the complexities. You just write your file to the network and everything is handled for you.

\begin{figure}[h]
	\begin{center}
		\includegraphics[width=\textwidth]{images/safe-wiki-uploading-coffee}
		\caption{Uploading the Coffee StackOverflow ZIM file to the SAFE Network}
		\label{fig:safe-upload-coffee}
	\end{center}
\end{figure}

When a user uploads their ZIM file they give it a name, again this name is important. This name is the `file name' of the file. Meaning that within a given `zim folder' the ZIM file is stored against the name the user specifies.

\subsection{Reading a ZIM File}

To access a given ZIM file, all a user has to provide to SAFE Wiki is the name of the ZIM folder and the name of the ZIM file within that folder. The \textit{address} for a given ZIM file hence consists of the name of the ZIM folder and its filename. This approach means it is easy to share access to ZIM files, as names can be human readable they are as easy to share as website URLs. The way I envision this being used is the name of the ZIM folder can correspond to the originator of the content then the filenames follow on logically from that. For example, `wikimedia' could be the name of the ZIM folder then `wikipedia' could be the name of the ZIM file. Meaning a user has two words to type in to access the latest version of Wikipedia. As things are organised like this it then becomes logical to derive the location of other ZIM files. A user can deduce that to get to `WikiVoyage' is as simple as `wikimedia' and `wikivoyage'.

The resolution of the 256-Bit XOR address of the ZIM Folder is through hashing. As the target ZIM folder was stored at the 256-Bit XOR Hash corresponding to the name specified by the owner of the ZIM folder, the address is then derivable by anyone else that knows the name. Hence when any other user specifies that name, e.g. `wikimedia', SAFE Wiki can easily find the Mutable Data Structure that houses the ZIM file the user wants to browse.
 
An important feature that is facilitated through the use of Data Maps is being able to randomly \textit{seek} through files. The Data Map contains enough information about a file that you can read arbitrary bytes from the file without your client having to download and assemble the entire contents of the DataMap. For ZIM files this is important, it is illogical for SAFE Wiki to download then entire Wikipedia so that you can read through a single article. 

\begin{figure}[h]
\begin{lstlisting}[frame=single]
readZim (zimFolder, filename, begin, size) {
  return new Promise(async (resolve, reject) => {
    try {
      const nfs = zimFolder.emulateAs('NFS')
      let file = await nfs.fetch(filename)
      file = await nfs.open(file, CONSTANTS.FILE_OPEN_MODE.OPEN_MODE_READ)
      let data = await file.read(begin, size)
      file.close()
      resolve(data)
    } catch (error) {
      reject(error)
    }
  })
}
\end{lstlisting}
\caption{Code to read a ZIM file from the SAFE Network}
\label{fig:zim-read-code}
\end{figure}

Kiwix JS by itself is setup to read ZIM files from local storage. To read files from the network all that happens is instead of reading a number of bytes (specified by begin and size) from local storage, the request is directed to the SAFE Network. Doing it this way is convenient because it doesn't require a complete overhaul of file reading in Kiwix JS. This approach, being more modular in design, means that the original functionality of Kiwix JS is maintained. You can select whether to read files locally or to read them from the SAFE network. In the Code Listing \ref{fig:zim-read-code} you can see how simple this code is. All that happens is the `zimFolder' that is a Mutable Data structure is emulated using NFS. Then the `file' is fetched through the `filename' specified by the user (e.g. `wikipedia`). To then read the required bytes is as simple as returning `file.read(begin, size)'. In Figure \ref{fig:browsing-coffee} you can see in the console on the right hand side the discrete reads from the network.

\begin{figure}
	\begin{center}
		\includegraphics[width=\textwidth]{images/safe-wiki-browsing-coffee}
		\caption{Browsing a page from the StackOverflow Coffee ZIM file on the SAFE Network}
		\label{fig:browsing-coffee}
	\end{center}
\end{figure}










